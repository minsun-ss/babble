apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: babel # Name of your application
  namespace: argocd # Should be in the argocd namespace
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: default # ArgoCD project name

  # Source of your application manifests
  source:
    repoURL: https://github.com/your-org/your-repo.git # Your Git repository URL
    targetRevision: main # Branch, tag, or commit hash
    path: k8s # Path to your Kubernetes manifests in the repo

  # Destination cluster and namespace
  destination:
    server: https://kubernetes.default.svc # URL of the Kubernetes API server
    namespace: babel # Target namespace for your application

  # Sync policy
  syncPolicy:
    automated:
      prune: true # Automatically delete resources that no longer exist in Git
      selfHeal: true # Automatically sync if drift is detected
      allowEmpty: false # Prevent deletion of all resources
    syncOptions:
      - CreateNamespace=true # Automatically create namespace if it doesn't exist
      - PrunePropagationPolicy=foreground
      - PruneLast=true # Delete resources as the last operation
      - Replace=true # Replace resources instead of applying changes

  # Sync wave and hook configuration
  syncWindows:
    - kind: allow
      schedule: "* * * * *" # Cron schedule for sync windows
      duration: "1h" # Duration of sync window
      applications:
        - "*" # Which applications this window applies to
      manualSync: true # Allow manual syncs outside window

  # Health check configuration
  ignoreDifferences:
    - group: apps
      kind: Deployment
      jsonPointers:
        - /spec/replicas
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: babel
  namespace: apps
spec:
  replicas: 1
  selector:
    matchLabels:
      app: babel
  template:
    metadata:
      labels:
        app: babel
    spec:
      containers:
        - name: babel
          image: your-registry/your-image:tag
          ports:
            - containerPort: 8080
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
---
# Service for the application
apiVersion: v1
kind: Service
metadata:
  name: babel
  namespace: apps
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 8080
      protocol: TCP
  selector:
    app: babel
---
# Ingress for external access
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: babel-ingress
  namespace: apps
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
spec:
  ingressClassName: nginx # Specify your ingress controller class
  rules:
    - host: myapp.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: babel
                port:
                  number: 80
  template:
    metadata:
      labels:
        app: babel
    spec:
      containers:
        - name: babel
          image: your-registry/your-image:tag
          ports:
            - containerPort: 8080
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 8080
            initialDelaySeconds: 15
            periodSeconds: 5
---
apiVersion: v1
kind: Secret
metadata:
  name: docker-images-credentials
  namespace: apps
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: <base64-encoded-docker-config>
